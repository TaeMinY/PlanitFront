{"remainingRequest":"/Users/macbookpro/Desktop/PlanitFront/node_modules/babel-loader/lib/index.js!/Users/macbookpro/Desktop/PlanitFront/node_modules/vuetify/lib/components/VCalendar/modes/stack.js","dependencies":[{"path":"/Users/macbookpro/Desktop/PlanitFront/node_modules/vuetify/lib/components/VCalendar/modes/stack.js","mtime":499162500000},{"path":"/Users/macbookpro/Desktop/PlanitFront/node_modules/cache-loader/dist/cjs.js","mtime":499162500000},{"path":"/Users/macbookpro/Desktop/PlanitFront/node_modules/babel-loader/lib/index.js","mtime":499162500000}],"contextDependencies":[],"result":[{"type":"Buffer","data":"base64:aW1wb3J0ICJjb3JlLWpzL21vZHVsZXMvZXMuc3ltYm9sIjsKaW1wb3J0ICJjb3JlLWpzL21vZHVsZXMvZXMuc3ltYm9sLmRlc2NyaXB0aW9uIjsKaW1wb3J0ICJjb3JlLWpzL21vZHVsZXMvZXMuc3ltYm9sLml0ZXJhdG9yIjsKaW1wb3J0ICJjb3JlLWpzL21vZHVsZXMvZXMuYXJyYXkuZmlsdGVyIjsKaW1wb3J0ICJjb3JlLWpzL21vZHVsZXMvZXMuYXJyYXkucmVkdWNlIjsKaW1wb3J0ICJjb3JlLWpzL21vZHVsZXMvZXMub2JqZWN0LnRvLXN0cmluZyI7CmltcG9ydCAiY29yZS1qcy9tb2R1bGVzL2VzLnN0cmluZy5pdGVyYXRvciI7CmltcG9ydCAiY29yZS1qcy9tb2R1bGVzL3dlYi5kb20tY29sbGVjdGlvbnMuaXRlcmF0b3IiOwppbXBvcnQgX3NsaWNlZFRvQXJyYXkgZnJvbSAiL1VzZXJzL21hY2Jvb2twcm8vRGVza3RvcC9QbGFuaXRGcm9udC9ub2RlX21vZHVsZXMvQGJhYmVsL3J1bnRpbWUvaGVscGVycy9lc20vc2xpY2VkVG9BcnJheSI7CmltcG9ydCB7IGdldE92ZXJsYXBHcm91cEhhbmRsZXIsIGdldFZpc3VhbHMsIGhhc092ZXJsYXAsIGdldE5vcm1hbGl6ZWRSYW5nZSB9IGZyb20gJy4vY29tbW9uJzsKaW1wb3J0IHsgZ2V0VGltZXN0YW1wSWRlbnRpZmllciB9IGZyb20gJy4uL3V0aWwvdGltZXN0YW1wJzsKdmFyIEZVTExfV0lEVEggPSAxMDA7CnZhciBERUZBVUxUX09GRlNFVCA9IDU7CnZhciBXSURUSF9NVUxUSVBMSUVSID0gMS43OwovKioKICogVmFyaWF0aW9uIG9mIGNvbHVtbiBtb2RlIHdoZXJlIGV2ZW50cyBjYW4gYmUgc3RhY2tlZC4gVGhlIHByaW9yaXR5IG9mIHRoaXMKICogbW9kZSBpcyB0byBzdGFjayBldmVudHMgdG9nZXRoZXIgdGFraW5nIHVwIHRoZSBsZWFzdCBhbW91bnQgb2Ygc3BhY2Ugd2hpbGUKICogdHJ5aW5nIHRvIGVuc3VyZSB0aGUgY29udGVudCBvZiB0aGUgZXZlbnQgaXMgYWx3YXlzIHZpc2libGUgYXMgd2VsbCBhcyBpdHMKICogc3RhcnQgYW5kIGVuZC4gQSBzaWJsaW5nIGNvbHVtbiBoYXMgaW50ZXJzZWN0aW5nIGV2ZW50IGNvbnRlbnQgYW5kIG11c3QgYmUKICogcGxhY2VkIGJlc2lkZSBlYWNoIG90aGVyLiBOb24tc2libGluZyBjb2x1bW5zIGFyZSBvZmZzZXQgYnkgNSUgZnJvbSB0aGUKICogcHJldmlvdXMgY29sdW1uLiBUaGUgd2lkdGggaXMgc2NhbGVkIGJ5IDEuNyBzbyB0aGUgZXZlbnRzIG92ZXJsYXAgYW5kCiAqIHdoaXRlc3BhY2UgaXMgcmVkdWNlZC4gSWYgdGhlcmUgaXMgYSBob2xlIGluIGNvbHVtbnMgdGhlIGV2ZW50IHdpZHRoIGlzCiAqIHNjYWxlZCB1cCBzbyBpdCBpbnRlcnNlY3RzIHdpdGggdGhlIG5leHQgY29sdW1uLiBUaGUgY29sdW1ucyBoYXZlIGVxdWFsCiAqIHdpZHRoIGluIHRoZSBzcGFjZSB0aGV5IGFyZSBnaXZlbi4gSWYgdGhlIGV2ZW50IGRvZXNuJ3QgaGF2ZSBhbnkgdG8gdGhlCiAqIHJpZ2h0IG9mIGl0IHRoYXQgaW50ZXJzZWN0IHdpdGggaXQncyBjb250ZW50IGl0J3MgcmlnaHQgc2lkZSBpcyBleHRlbmRlZAogKiB0byB0aGUgcmlnaHQgc2lkZS4KICovCgpleHBvcnQgdmFyIHN0YWNrID0gZnVuY3Rpb24gc3RhY2soZXZlbnRzLCBmaXJzdFdlZWtkYXksIG92ZXJsYXBUaHJlc2hvbGQpIHsKICB2YXIgaGFuZGxlciA9IGdldE92ZXJsYXBHcm91cEhhbmRsZXIoZmlyc3RXZWVrZGF5KTsgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG1heC1zdGF0ZW1lbnRzCgogIHJldHVybiBmdW5jdGlvbiAoZGF5LCBkYXlFdmVudHMsIHRpbWVkKSB7CiAgICBpZiAoIXRpbWVkKSB7CiAgICAgIHJldHVybiBoYW5kbGVyLmdldFZpc3VhbHMoZGF5LCBkYXlFdmVudHMsIHRpbWVkKTsKICAgIH0KCiAgICB2YXIgZGF5U3RhcnQgPSBnZXRUaW1lc3RhbXBJZGVudGlmaWVyKGRheSk7CiAgICB2YXIgdmlzdWFscyA9IGdldFZpc3VhbHMoZGF5RXZlbnRzLCBkYXlTdGFydCk7CiAgICB2YXIgZ3JvdXBzID0gZ2V0R3JvdXBzKHZpc3VhbHMsIGRheVN0YXJ0KTsKICAgIHZhciBfaXRlcmF0b3JOb3JtYWxDb21wbGV0aW9uID0gdHJ1ZTsKICAgIHZhciBfZGlkSXRlcmF0b3JFcnJvciA9IGZhbHNlOwogICAgdmFyIF9pdGVyYXRvckVycm9yID0gdW5kZWZpbmVkOwoKICAgIHRyeSB7CiAgICAgIGZvciAodmFyIF9pdGVyYXRvciA9IGdyb3Vwc1tTeW1ib2wuaXRlcmF0b3JdKCksIF9zdGVwOyAhKF9pdGVyYXRvck5vcm1hbENvbXBsZXRpb24gPSAoX3N0ZXAgPSBfaXRlcmF0b3IubmV4dCgpKS5kb25lKTsgX2l0ZXJhdG9yTm9ybWFsQ29tcGxldGlvbiA9IHRydWUpIHsKICAgICAgICB2YXIgZ3JvdXAgPSBfc3RlcC52YWx1ZTsKICAgICAgICB2YXIgbm9kZXMgPSBbXTsKICAgICAgICB2YXIgX2l0ZXJhdG9yTm9ybWFsQ29tcGxldGlvbjIgPSB0cnVlOwogICAgICAgIHZhciBfZGlkSXRlcmF0b3JFcnJvcjIgPSBmYWxzZTsKICAgICAgICB2YXIgX2l0ZXJhdG9yRXJyb3IyID0gdW5kZWZpbmVkOwoKICAgICAgICB0cnkgewogICAgICAgICAgZm9yICh2YXIgX2l0ZXJhdG9yMiA9IGdyb3VwLnZpc3VhbHNbU3ltYm9sLml0ZXJhdG9yXSgpLCBfc3RlcDI7ICEoX2l0ZXJhdG9yTm9ybWFsQ29tcGxldGlvbjIgPSAoX3N0ZXAyID0gX2l0ZXJhdG9yMi5uZXh0KCkpLmRvbmUpOyBfaXRlcmF0b3JOb3JtYWxDb21wbGV0aW9uMiA9IHRydWUpIHsKICAgICAgICAgICAgdmFyIHZpc3VhbCA9IF9zdGVwMi52YWx1ZTsKICAgICAgICAgICAgdmFyIGNoaWxkID0gZ2V0Tm9kZSh2aXN1YWwsIGRheVN0YXJ0KTsKICAgICAgICAgICAgdmFyIGluZGV4ID0gZ2V0TmV4dEluZGV4KGNoaWxkLCBub2Rlcyk7CgogICAgICAgICAgICBpZiAoaW5kZXggPT09IGZhbHNlKSB7CiAgICAgICAgICAgICAgdmFyIHBhcmVudCA9IGdldFBhcmVudChjaGlsZCwgbm9kZXMpOwoKICAgICAgICAgICAgICBpZiAocGFyZW50KSB7CiAgICAgICAgICAgICAgICBjaGlsZC5wYXJlbnQgPSBwYXJlbnQ7CiAgICAgICAgICAgICAgICBjaGlsZC5zaWJsaW5nID0gaGFzT3ZlcmxhcChjaGlsZC5zdGFydCwgY2hpbGQuZW5kLCBwYXJlbnQuc3RhcnQsIGFkZFRpbWUocGFyZW50LnN0YXJ0LCBvdmVybGFwVGhyZXNob2xkKSk7CiAgICAgICAgICAgICAgICBjaGlsZC5pbmRleCA9IHBhcmVudC5pbmRleCArIDE7CiAgICAgICAgICAgICAgICBwYXJlbnQuY2hpbGRyZW4ucHVzaChjaGlsZCk7CiAgICAgICAgICAgICAgfQogICAgICAgICAgICB9IGVsc2UgewogICAgICAgICAgICAgIHZhciBfZ2V0T3ZlcmxhcHBpbmdSYW5nZSA9IGdldE92ZXJsYXBwaW5nUmFuZ2UoY2hpbGQsIG5vZGVzLCBpbmRleCAtIDEsIGluZGV4IC0gMSksCiAgICAgICAgICAgICAgICAgIF9nZXRPdmVybGFwcGluZ1JhbmdlMiA9IF9zbGljZWRUb0FycmF5KF9nZXRPdmVybGFwcGluZ1JhbmdlLCAxKSwKICAgICAgICAgICAgICAgICAgX3BhcmVudCA9IF9nZXRPdmVybGFwcGluZ1JhbmdlMlswXTsKCiAgICAgICAgICAgICAgdmFyIGNoaWxkcmVuID0gZ2V0T3ZlcmxhcHBpbmdSYW5nZShjaGlsZCwgbm9kZXMsIGluZGV4ICsgMSwgaW5kZXggKyBub2Rlcy5sZW5ndGgsIHRydWUpOwogICAgICAgICAgICAgIGNoaWxkLmNoaWxkcmVuID0gY2hpbGRyZW47CiAgICAgICAgICAgICAgY2hpbGQuaW5kZXggPSBpbmRleDsKCiAgICAgICAgICAgICAgaWYgKF9wYXJlbnQpIHsKICAgICAgICAgICAgICAgIGNoaWxkLnBhcmVudCA9IF9wYXJlbnQ7CiAgICAgICAgICAgICAgICBjaGlsZC5zaWJsaW5nID0gaGFzT3ZlcmxhcChjaGlsZC5zdGFydCwgY2hpbGQuZW5kLCBfcGFyZW50LnN0YXJ0LCBhZGRUaW1lKF9wYXJlbnQuc3RhcnQsIG92ZXJsYXBUaHJlc2hvbGQpKTsKCiAgICAgICAgICAgICAgICBfcGFyZW50LmNoaWxkcmVuLnB1c2goY2hpbGQpOwogICAgICAgICAgICAgIH0KCiAgICAgICAgICAgICAgdmFyIF9pdGVyYXRvck5vcm1hbENvbXBsZXRpb24zID0gdHJ1ZTsKICAgICAgICAgICAgICB2YXIgX2RpZEl0ZXJhdG9yRXJyb3IzID0gZmFsc2U7CiAgICAgICAgICAgICAgdmFyIF9pdGVyYXRvckVycm9yMyA9IHVuZGVmaW5lZDsKCiAgICAgICAgICAgICAgdHJ5IHsKICAgICAgICAgICAgICAgIGZvciAodmFyIF9pdGVyYXRvcjMgPSBjaGlsZHJlbltTeW1ib2wuaXRlcmF0b3JdKCksIF9zdGVwMzsgIShfaXRlcmF0b3JOb3JtYWxDb21wbGV0aW9uMyA9IChfc3RlcDMgPSBfaXRlcmF0b3IzLm5leHQoKSkuZG9uZSk7IF9pdGVyYXRvck5vcm1hbENvbXBsZXRpb24zID0gdHJ1ZSkgewogICAgICAgICAgICAgICAgICB2YXIgZ3JhbmQgPSBfc3RlcDMudmFsdWU7CgogICAgICAgICAgICAgICAgICBpZiAoZ3JhbmQucGFyZW50ID09PSBfcGFyZW50KSB7CiAgICAgICAgICAgICAgICAgICAgZ3JhbmQucGFyZW50ID0gY2hpbGQ7CiAgICAgICAgICAgICAgICAgIH0KCiAgICAgICAgICAgICAgICAgIHZhciBncmFuZE5leHQgPSBncmFuZC5pbmRleCAtIGNoaWxkLmluZGV4IDw9IDE7CgogICAgICAgICAgICAgICAgICBpZiAoZ3JhbmROZXh0ICYmIGNoaWxkLnNpYmxpbmcgJiYgaGFzT3ZlcmxhcChjaGlsZC5zdGFydCwgYWRkVGltZShjaGlsZC5zdGFydCwgb3ZlcmxhcFRocmVzaG9sZCksIGdyYW5kLnN0YXJ0LCBncmFuZC5lbmQpKSB7CiAgICAgICAgICAgICAgICAgICAgZ3JhbmQuc2libGluZyA9IHRydWU7CiAgICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgICB9IGNhdGNoIChlcnIpIHsKICAgICAgICAgICAgICAgIF9kaWRJdGVyYXRvckVycm9yMyA9IHRydWU7CiAgICAgICAgICAgICAgICBfaXRlcmF0b3JFcnJvcjMgPSBlcnI7CiAgICAgICAgICAgICAgfSBmaW5hbGx5IHsKICAgICAgICAgICAgICAgIHRyeSB7CiAgICAgICAgICAgICAgICAgIGlmICghX2l0ZXJhdG9yTm9ybWFsQ29tcGxldGlvbjMgJiYgX2l0ZXJhdG9yMy5yZXR1cm4gIT0gbnVsbCkgewogICAgICAgICAgICAgICAgICAgIF9pdGVyYXRvcjMucmV0dXJuKCk7CiAgICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgICAgIH0gZmluYWxseSB7CiAgICAgICAgICAgICAgICAgIGlmIChfZGlkSXRlcmF0b3JFcnJvcjMpIHsKICAgICAgICAgICAgICAgICAgICB0aHJvdyBfaXRlcmF0b3JFcnJvcjM7CiAgICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgICB9CiAgICAgICAgICAgIH0KCiAgICAgICAgICAgIG5vZGVzLnB1c2goY2hpbGQpOwogICAgICAgICAgfQogICAgICAgIH0gY2F0Y2ggKGVycikgewogICAgICAgICAgX2RpZEl0ZXJhdG9yRXJyb3IyID0gdHJ1ZTsKICAgICAgICAgIF9pdGVyYXRvckVycm9yMiA9IGVycjsKICAgICAgICB9IGZpbmFsbHkgewogICAgICAgICAgdHJ5IHsKICAgICAgICAgICAgaWYgKCFfaXRlcmF0b3JOb3JtYWxDb21wbGV0aW9uMiAmJiBfaXRlcmF0b3IyLnJldHVybiAhPSBudWxsKSB7CiAgICAgICAgICAgICAgX2l0ZXJhdG9yMi5yZXR1cm4oKTsKICAgICAgICAgICAgfQogICAgICAgICAgfSBmaW5hbGx5IHsKICAgICAgICAgICAgaWYgKF9kaWRJdGVyYXRvckVycm9yMikgewogICAgICAgICAgICAgIHRocm93IF9pdGVyYXRvckVycm9yMjsKICAgICAgICAgICAgfQogICAgICAgICAgfQogICAgICAgIH0KCiAgICAgICAgY2FsY3VsYXRlQm91bmRzKG5vZGVzLCBvdmVybGFwVGhyZXNob2xkKTsKICAgICAgfQogICAgfSBjYXRjaCAoZXJyKSB7CiAgICAgIF9kaWRJdGVyYXRvckVycm9yID0gdHJ1ZTsKICAgICAgX2l0ZXJhdG9yRXJyb3IgPSBlcnI7CiAgICB9IGZpbmFsbHkgewogICAgICB0cnkgewogICAgICAgIGlmICghX2l0ZXJhdG9yTm9ybWFsQ29tcGxldGlvbiAmJiBfaXRlcmF0b3IucmV0dXJuICE9IG51bGwpIHsKICAgICAgICAgIF9pdGVyYXRvci5yZXR1cm4oKTsKICAgICAgICB9CiAgICAgIH0gZmluYWxseSB7CiAgICAgICAgaWYgKF9kaWRJdGVyYXRvckVycm9yKSB7CiAgICAgICAgICB0aHJvdyBfaXRlcmF0b3JFcnJvcjsKICAgICAgICB9CiAgICAgIH0KICAgIH0KCiAgICB2aXN1YWxzLnNvcnQoZnVuY3Rpb24gKGEsIGIpIHsKICAgICAgcmV0dXJuIGEubGVmdCAtIGIubGVmdCB8fCBhLmV2ZW50LnN0YXJ0VGltZXN0YW1wSWRlbnRpZmllciAtIGIuZXZlbnQuc3RhcnRUaW1lc3RhbXBJZGVudGlmaWVyOwogICAgfSk7CiAgICByZXR1cm4gdmlzdWFsczsKICB9Owp9OwoKZnVuY3Rpb24gY2FsY3VsYXRlQm91bmRzKG5vZGVzLCBvdmVybGFwVGhyZXNob2xkKSB7CiAgdmFyIF9pdGVyYXRvck5vcm1hbENvbXBsZXRpb240ID0gdHJ1ZTsKICB2YXIgX2RpZEl0ZXJhdG9yRXJyb3I0ID0gZmFsc2U7CiAgdmFyIF9pdGVyYXRvckVycm9yNCA9IHVuZGVmaW5lZDsKCiAgdHJ5IHsKICAgIGZvciAodmFyIF9pdGVyYXRvcjQgPSBub2Rlc1tTeW1ib2wuaXRlcmF0b3JdKCksIF9zdGVwNDsgIShfaXRlcmF0b3JOb3JtYWxDb21wbGV0aW9uNCA9IChfc3RlcDQgPSBfaXRlcmF0b3I0Lm5leHQoKSkuZG9uZSk7IF9pdGVyYXRvck5vcm1hbENvbXBsZXRpb240ID0gdHJ1ZSkgewogICAgICB2YXIgbm9kZSA9IF9zdGVwNC52YWx1ZTsKICAgICAgdmFyIHZpc3VhbCA9IG5vZGUudmlzdWFsLAogICAgICAgICAgcGFyZW50ID0gbm9kZS5wYXJlbnQ7CiAgICAgIHZhciBjb2x1bW5zID0gZ2V0TWF4Q2hpbGRJbmRleChub2RlKSArIDE7CiAgICAgIHZhciBzcGFjZUxlZnQgPSBwYXJlbnQgPyBwYXJlbnQudmlzdWFsLmxlZnQgOiAwOwogICAgICB2YXIgc3BhY2VXaWR0aCA9IEZVTExfV0lEVEggLSBzcGFjZUxlZnQ7CiAgICAgIHZhciBvZmZzZXQgPSBNYXRoLm1pbihERUZBVUxUX09GRlNFVCwgRlVMTF9XSURUSCAvIGNvbHVtbnMpOwogICAgICB2YXIgY29sdW1uV2lkdGhNdWx0aXBsaWVyID0gZ2V0Q29sdW1uV2lkdGhNdWx0aXBsaWVyKG5vZGUsIG5vZGVzKTsKICAgICAgdmFyIGNvbHVtbk9mZnNldCA9IHNwYWNlV2lkdGggLyAoY29sdW1ucyAtIG5vZGUuaW5kZXggKyAxKTsKICAgICAgdmFyIGNvbHVtbldpZHRoID0gc3BhY2VXaWR0aCAvIChjb2x1bW5zIC0gbm9kZS5pbmRleCArIChub2RlLnNpYmxpbmcgPyAxIDogMCkpICogY29sdW1uV2lkdGhNdWx0aXBsaWVyOwoKICAgICAgaWYgKHBhcmVudCkgewogICAgICAgIHZpc3VhbC5sZWZ0ID0gbm9kZS5zaWJsaW5nID8gc3BhY2VMZWZ0ICsgY29sdW1uT2Zmc2V0IDogc3BhY2VMZWZ0ICsgb2Zmc2V0OwogICAgICB9CgogICAgICB2aXN1YWwud2lkdGggPSBoYXNGdWxsV2lkdGgobm9kZSwgbm9kZXMsIG92ZXJsYXBUaHJlc2hvbGQpID8gRlVMTF9XSURUSCAtIHZpc3VhbC5sZWZ0IDogTWF0aC5taW4oRlVMTF9XSURUSCAtIHZpc3VhbC5sZWZ0LCBjb2x1bW5XaWR0aCAqIFdJRFRIX01VTFRJUExJRVIpOwogICAgfQogIH0gY2F0Y2ggKGVycikgewogICAgX2RpZEl0ZXJhdG9yRXJyb3I0ID0gdHJ1ZTsKICAgIF9pdGVyYXRvckVycm9yNCA9IGVycjsKICB9IGZpbmFsbHkgewogICAgdHJ5IHsKICAgICAgaWYgKCFfaXRlcmF0b3JOb3JtYWxDb21wbGV0aW9uNCAmJiBfaXRlcmF0b3I0LnJldHVybiAhPSBudWxsKSB7CiAgICAgICAgX2l0ZXJhdG9yNC5yZXR1cm4oKTsKICAgICAgfQogICAgfSBmaW5hbGx5IHsKICAgICAgaWYgKF9kaWRJdGVyYXRvckVycm9yNCkgewogICAgICAgIHRocm93IF9pdGVyYXRvckVycm9yNDsKICAgICAgfQogICAgfQogIH0KfQoKZnVuY3Rpb24gZ2V0Q29sdW1uV2lkdGhNdWx0aXBsaWVyKG5vZGUsIG5vZGVzKSB7CiAgaWYgKCFub2RlLmNoaWxkcmVuLmxlbmd0aCkgewogICAgcmV0dXJuIDE7CiAgfQoKICB2YXIgbWF4Q29sdW1uID0gbm9kZS5pbmRleCArIG5vZGVzLmxlbmd0aDsKICB2YXIgbWluQ29sdW1uID0gbm9kZS5jaGlsZHJlbi5yZWR1Y2UoZnVuY3Rpb24gKG1pbiwgYykgewogICAgcmV0dXJuIE1hdGgubWluKG1pbiwgYy5pbmRleCk7CiAgfSwgbWF4Q29sdW1uKTsKICByZXR1cm4gbWluQ29sdW1uIC0gbm9kZS5pbmRleDsKfQoKZnVuY3Rpb24gZ2V0T3ZlcmxhcHBpbmdJbmRpY2VzKG5vZGUsIG5vZGVzKSB7CiAgdmFyIGluZGljZXMgPSBbXTsKICB2YXIgX2l0ZXJhdG9yTm9ybWFsQ29tcGxldGlvbjUgPSB0cnVlOwogIHZhciBfZGlkSXRlcmF0b3JFcnJvcjUgPSBmYWxzZTsKICB2YXIgX2l0ZXJhdG9yRXJyb3I1ID0gdW5kZWZpbmVkOwoKICB0cnkgewogICAgZm9yICh2YXIgX2l0ZXJhdG9yNSA9IG5vZGVzW1N5bWJvbC5pdGVyYXRvcl0oKSwgX3N0ZXA1OyAhKF9pdGVyYXRvck5vcm1hbENvbXBsZXRpb241ID0gKF9zdGVwNSA9IF9pdGVyYXRvcjUubmV4dCgpKS5kb25lKTsgX2l0ZXJhdG9yTm9ybWFsQ29tcGxldGlvbjUgPSB0cnVlKSB7CiAgICAgIHZhciBvdGhlciA9IF9zdGVwNS52YWx1ZTsKCiAgICAgIGlmIChoYXNPdmVybGFwKG5vZGUuc3RhcnQsIG5vZGUuZW5kLCBvdGhlci5zdGFydCwgb3RoZXIuZW5kKSkgewogICAgICAgIGluZGljZXMucHVzaChvdGhlci5pbmRleCk7CiAgICAgIH0KICAgIH0KICB9IGNhdGNoIChlcnIpIHsKICAgIF9kaWRJdGVyYXRvckVycm9yNSA9IHRydWU7CiAgICBfaXRlcmF0b3JFcnJvcjUgPSBlcnI7CiAgfSBmaW5hbGx5IHsKICAgIHRyeSB7CiAgICAgIGlmICghX2l0ZXJhdG9yTm9ybWFsQ29tcGxldGlvbjUgJiYgX2l0ZXJhdG9yNS5yZXR1cm4gIT0gbnVsbCkgewogICAgICAgIF9pdGVyYXRvcjUucmV0dXJuKCk7CiAgICAgIH0KICAgIH0gZmluYWxseSB7CiAgICAgIGlmIChfZGlkSXRlcmF0b3JFcnJvcjUpIHsKICAgICAgICB0aHJvdyBfaXRlcmF0b3JFcnJvcjU7CiAgICAgIH0KICAgIH0KICB9CgogIHJldHVybiBpbmRpY2VzOwp9CgpmdW5jdGlvbiBnZXROZXh0SW5kZXgobm9kZSwgbm9kZXMpIHsKICB2YXIgaW5kaWNlcyA9IGdldE92ZXJsYXBwaW5nSW5kaWNlcyhub2RlLCBub2Rlcyk7CiAgaW5kaWNlcy5zb3J0KCk7CgogIGZvciAodmFyIGkgPSAwOyBpIDwgaW5kaWNlcy5sZW5ndGg7IGkrKykgewogICAgaWYgKGkgPCBpbmRpY2VzW2ldKSB7CiAgICAgIHJldHVybiBpOwogICAgfQogIH0KCiAgcmV0dXJuIGZhbHNlOwp9CgpmdW5jdGlvbiBnZXRPdmVybGFwcGluZ1JhbmdlKG5vZGUsIG5vZGVzLCBpbmRleE1pbiwgaW5kZXhNYXgpIHsKICB2YXIgcmV0dXJuRmlyc3RDb2x1bW4gPSBhcmd1bWVudHMubGVuZ3RoID4gNCAmJiBhcmd1bWVudHNbNF0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1s0XSA6IGZhbHNlOwogIHZhciBvdmVybGFwcGluZyA9IFtdOwogIHZhciBfaXRlcmF0b3JOb3JtYWxDb21wbGV0aW9uNiA9IHRydWU7CiAgdmFyIF9kaWRJdGVyYXRvckVycm9yNiA9IGZhbHNlOwogIHZhciBfaXRlcmF0b3JFcnJvcjYgPSB1bmRlZmluZWQ7CgogIHRyeSB7CiAgICBmb3IgKHZhciBfaXRlcmF0b3I2ID0gbm9kZXNbU3ltYm9sLml0ZXJhdG9yXSgpLCBfc3RlcDY7ICEoX2l0ZXJhdG9yTm9ybWFsQ29tcGxldGlvbjYgPSAoX3N0ZXA2ID0gX2l0ZXJhdG9yNi5uZXh0KCkpLmRvbmUpOyBfaXRlcmF0b3JOb3JtYWxDb21wbGV0aW9uNiA9IHRydWUpIHsKICAgICAgdmFyIG90aGVyID0gX3N0ZXA2LnZhbHVlOwoKICAgICAgaWYgKG90aGVyLmluZGV4ID49IGluZGV4TWluICYmIG90aGVyLmluZGV4IDw9IGluZGV4TWF4ICYmIGhhc092ZXJsYXAobm9kZS5zdGFydCwgbm9kZS5lbmQsIG90aGVyLnN0YXJ0LCBvdGhlci5lbmQpKSB7CiAgICAgICAgb3ZlcmxhcHBpbmcucHVzaChvdGhlcik7CiAgICAgIH0KICAgIH0KICB9IGNhdGNoIChlcnIpIHsKICAgIF9kaWRJdGVyYXRvckVycm9yNiA9IHRydWU7CiAgICBfaXRlcmF0b3JFcnJvcjYgPSBlcnI7CiAgfSBmaW5hbGx5IHsKICAgIHRyeSB7CiAgICAgIGlmICghX2l0ZXJhdG9yTm9ybWFsQ29tcGxldGlvbjYgJiYgX2l0ZXJhdG9yNi5yZXR1cm4gIT0gbnVsbCkgewogICAgICAgIF9pdGVyYXRvcjYucmV0dXJuKCk7CiAgICAgIH0KICAgIH0gZmluYWxseSB7CiAgICAgIGlmIChfZGlkSXRlcmF0b3JFcnJvcjYpIHsKICAgICAgICB0aHJvdyBfaXRlcmF0b3JFcnJvcjY7CiAgICAgIH0KICAgIH0KICB9CgogIGlmIChyZXR1cm5GaXJzdENvbHVtbiAmJiBvdmVybGFwcGluZy5sZW5ndGggPiAwKSB7CiAgICB2YXIgZmlyc3QgPSBvdmVybGFwcGluZy5yZWR1Y2UoZnVuY3Rpb24gKG1pbiwgbikgewogICAgICByZXR1cm4gTWF0aC5taW4obWluLCBuLmluZGV4KTsKICAgIH0sIG92ZXJsYXBwaW5nWzBdLmluZGV4KTsKICAgIHJldHVybiBvdmVybGFwcGluZy5maWx0ZXIoZnVuY3Rpb24gKG4pIHsKICAgICAgcmV0dXJuIG4uaW5kZXggPT09IGZpcnN0OwogICAgfSk7CiAgfQoKICByZXR1cm4gb3ZlcmxhcHBpbmc7Cn0KCmZ1bmN0aW9uIGdldFBhcmVudChub2RlLCBub2RlcykgewogIHZhciBwYXJlbnQgPSBudWxsOwogIHZhciBfaXRlcmF0b3JOb3JtYWxDb21wbGV0aW9uNyA9IHRydWU7CiAgdmFyIF9kaWRJdGVyYXRvckVycm9yNyA9IGZhbHNlOwogIHZhciBfaXRlcmF0b3JFcnJvcjcgPSB1bmRlZmluZWQ7CgogIHRyeSB7CiAgICBmb3IgKHZhciBfaXRlcmF0b3I3ID0gbm9kZXNbU3ltYm9sLml0ZXJhdG9yXSgpLCBfc3RlcDc7ICEoX2l0ZXJhdG9yTm9ybWFsQ29tcGxldGlvbjcgPSAoX3N0ZXA3ID0gX2l0ZXJhdG9yNy5uZXh0KCkpLmRvbmUpOyBfaXRlcmF0b3JOb3JtYWxDb21wbGV0aW9uNyA9IHRydWUpIHsKICAgICAgdmFyIG90aGVyID0gX3N0ZXA3LnZhbHVlOwoKICAgICAgaWYgKGhhc092ZXJsYXAobm9kZS5zdGFydCwgbm9kZS5lbmQsIG90aGVyLnN0YXJ0LCBvdGhlci5lbmQpICYmIChwYXJlbnQgPT09IG51bGwgfHwgb3RoZXIuaW5kZXggPiBwYXJlbnQuaW5kZXgpKSB7CiAgICAgICAgcGFyZW50ID0gb3RoZXI7CiAgICAgIH0KICAgIH0KICB9IGNhdGNoIChlcnIpIHsKICAgIF9kaWRJdGVyYXRvckVycm9yNyA9IHRydWU7CiAgICBfaXRlcmF0b3JFcnJvcjcgPSBlcnI7CiAgfSBmaW5hbGx5IHsKICAgIHRyeSB7CiAgICAgIGlmICghX2l0ZXJhdG9yTm9ybWFsQ29tcGxldGlvbjcgJiYgX2l0ZXJhdG9yNy5yZXR1cm4gIT0gbnVsbCkgewogICAgICAgIF9pdGVyYXRvcjcucmV0dXJuKCk7CiAgICAgIH0KICAgIH0gZmluYWxseSB7CiAgICAgIGlmIChfZGlkSXRlcmF0b3JFcnJvcjcpIHsKICAgICAgICB0aHJvdyBfaXRlcmF0b3JFcnJvcjc7CiAgICAgIH0KICAgIH0KICB9CgogIHJldHVybiBwYXJlbnQ7Cn0KCmZ1bmN0aW9uIGhhc0Z1bGxXaWR0aChub2RlLCBub2Rlcywgb3ZlcmxhcFRocmVzaG9sZCkgewogIHZhciBfaXRlcmF0b3JOb3JtYWxDb21wbGV0aW9uOCA9IHRydWU7CiAgdmFyIF9kaWRJdGVyYXRvckVycm9yOCA9IGZhbHNlOwogIHZhciBfaXRlcmF0b3JFcnJvcjggPSB1bmRlZmluZWQ7CgogIHRyeSB7CiAgICBmb3IgKHZhciBfaXRlcmF0b3I4ID0gbm9kZXNbU3ltYm9sLml0ZXJhdG9yXSgpLCBfc3RlcDg7ICEoX2l0ZXJhdG9yTm9ybWFsQ29tcGxldGlvbjggPSAoX3N0ZXA4ID0gX2l0ZXJhdG9yOC5uZXh0KCkpLmRvbmUpOyBfaXRlcmF0b3JOb3JtYWxDb21wbGV0aW9uOCA9IHRydWUpIHsKICAgICAgdmFyIG90aGVyID0gX3N0ZXA4LnZhbHVlOwoKICAgICAgaWYgKG90aGVyICE9PSBub2RlICYmIG90aGVyLmluZGV4ID4gbm9kZS5pbmRleCAmJiBoYXNPdmVybGFwKG5vZGUuc3RhcnQsIGFkZFRpbWUobm9kZS5zdGFydCwgb3ZlcmxhcFRocmVzaG9sZCksIG90aGVyLnN0YXJ0LCBvdGhlci5lbmQpKSB7CiAgICAgICAgcmV0dXJuIGZhbHNlOwogICAgICB9CiAgICB9CiAgfSBjYXRjaCAoZXJyKSB7CiAgICBfZGlkSXRlcmF0b3JFcnJvcjggPSB0cnVlOwogICAgX2l0ZXJhdG9yRXJyb3I4ID0gZXJyOwogIH0gZmluYWxseSB7CiAgICB0cnkgewogICAgICBpZiAoIV9pdGVyYXRvck5vcm1hbENvbXBsZXRpb244ICYmIF9pdGVyYXRvcjgucmV0dXJuICE9IG51bGwpIHsKICAgICAgICBfaXRlcmF0b3I4LnJldHVybigpOwogICAgICB9CiAgICB9IGZpbmFsbHkgewogICAgICBpZiAoX2RpZEl0ZXJhdG9yRXJyb3I4KSB7CiAgICAgICAgdGhyb3cgX2l0ZXJhdG9yRXJyb3I4OwogICAgICB9CiAgICB9CiAgfQoKICByZXR1cm4gdHJ1ZTsKfQoKZnVuY3Rpb24gZ2V0R3JvdXBzKHZpc3VhbHMsIGRheVN0YXJ0KSB7CiAgdmFyIGdyb3VwcyA9IFtdOwogIHZhciBfaXRlcmF0b3JOb3JtYWxDb21wbGV0aW9uOSA9IHRydWU7CiAgdmFyIF9kaWRJdGVyYXRvckVycm9yOSA9IGZhbHNlOwogIHZhciBfaXRlcmF0b3JFcnJvcjkgPSB1bmRlZmluZWQ7CgogIHRyeSB7CiAgICBmb3IgKHZhciBfaXRlcmF0b3I5ID0gdmlzdWFsc1tTeW1ib2wuaXRlcmF0b3JdKCksIF9zdGVwOTsgIShfaXRlcmF0b3JOb3JtYWxDb21wbGV0aW9uOSA9IChfc3RlcDkgPSBfaXRlcmF0b3I5Lm5leHQoKSkuZG9uZSk7IF9pdGVyYXRvck5vcm1hbENvbXBsZXRpb245ID0gdHJ1ZSkgewogICAgICB2YXIgdmlzdWFsID0gX3N0ZXA5LnZhbHVlOwoKICAgICAgdmFyIF9nZXROb3JtYWxpemVkUmFuZ2UgPSBnZXROb3JtYWxpemVkUmFuZ2UodmlzdWFsLmV2ZW50LCBkYXlTdGFydCksCiAgICAgICAgICBfZ2V0Tm9ybWFsaXplZFJhbmdlMiA9IF9zbGljZWRUb0FycmF5KF9nZXROb3JtYWxpemVkUmFuZ2UsIDIpLAogICAgICAgICAgc3RhcnQgPSBfZ2V0Tm9ybWFsaXplZFJhbmdlMlswXSwKICAgICAgICAgIGVuZCA9IF9nZXROb3JtYWxpemVkUmFuZ2UyWzFdOwoKICAgICAgdmFyIGFkZGVkID0gZmFsc2U7CiAgICAgIHZhciBfaXRlcmF0b3JOb3JtYWxDb21wbGV0aW9uMTAgPSB0cnVlOwogICAgICB2YXIgX2RpZEl0ZXJhdG9yRXJyb3IxMCA9IGZhbHNlOwogICAgICB2YXIgX2l0ZXJhdG9yRXJyb3IxMCA9IHVuZGVmaW5lZDsKCiAgICAgIHRyeSB7CiAgICAgICAgZm9yICh2YXIgX2l0ZXJhdG9yMTAgPSBncm91cHNbU3ltYm9sLml0ZXJhdG9yXSgpLCBfc3RlcDEwOyAhKF9pdGVyYXRvck5vcm1hbENvbXBsZXRpb24xMCA9IChfc3RlcDEwID0gX2l0ZXJhdG9yMTAubmV4dCgpKS5kb25lKTsgX2l0ZXJhdG9yTm9ybWFsQ29tcGxldGlvbjEwID0gdHJ1ZSkgewogICAgICAgICAgdmFyIGdyb3VwID0gX3N0ZXAxMC52YWx1ZTsKCiAgICAgICAgICBpZiAoaGFzT3ZlcmxhcChzdGFydCwgZW5kLCBncm91cC5zdGFydCwgZ3JvdXAuZW5kKSkgewogICAgICAgICAgICBncm91cC52aXN1YWxzLnB1c2godmlzdWFsKTsKICAgICAgICAgICAgZ3JvdXAuZW5kID0gTWF0aC5tYXgoZ3JvdXAuZW5kLCBlbmQpOwogICAgICAgICAgICBhZGRlZCA9IHRydWU7CiAgICAgICAgICAgIGJyZWFrOwogICAgICAgICAgfQogICAgICAgIH0KICAgICAgfSBjYXRjaCAoZXJyKSB7CiAgICAgICAgX2RpZEl0ZXJhdG9yRXJyb3IxMCA9IHRydWU7CiAgICAgICAgX2l0ZXJhdG9yRXJyb3IxMCA9IGVycjsKICAgICAgfSBmaW5hbGx5IHsKICAgICAgICB0cnkgewogICAgICAgICAgaWYgKCFfaXRlcmF0b3JOb3JtYWxDb21wbGV0aW9uMTAgJiYgX2l0ZXJhdG9yMTAucmV0dXJuICE9IG51bGwpIHsKICAgICAgICAgICAgX2l0ZXJhdG9yMTAucmV0dXJuKCk7CiAgICAgICAgICB9CiAgICAgICAgfSBmaW5hbGx5IHsKICAgICAgICAgIGlmIChfZGlkSXRlcmF0b3JFcnJvcjEwKSB7CiAgICAgICAgICAgIHRocm93IF9pdGVyYXRvckVycm9yMTA7CiAgICAgICAgICB9CiAgICAgICAgfQogICAgICB9CgogICAgICBpZiAoIWFkZGVkKSB7CiAgICAgICAgZ3JvdXBzLnB1c2goewogICAgICAgICAgc3RhcnQ6IHN0YXJ0LAogICAgICAgICAgZW5kOiBlbmQsCiAgICAgICAgICB2aXN1YWxzOiBbdmlzdWFsXQogICAgICAgIH0pOwogICAgICB9CiAgICB9CiAgfSBjYXRjaCAoZXJyKSB7CiAgICBfZGlkSXRlcmF0b3JFcnJvcjkgPSB0cnVlOwogICAgX2l0ZXJhdG9yRXJyb3I5ID0gZXJyOwogIH0gZmluYWxseSB7CiAgICB0cnkgewogICAgICBpZiAoIV9pdGVyYXRvck5vcm1hbENvbXBsZXRpb245ICYmIF9pdGVyYXRvcjkucmV0dXJuICE9IG51bGwpIHsKICAgICAgICBfaXRlcmF0b3I5LnJldHVybigpOwogICAgICB9CiAgICB9IGZpbmFsbHkgewogICAgICBpZiAoX2RpZEl0ZXJhdG9yRXJyb3I5KSB7CiAgICAgICAgdGhyb3cgX2l0ZXJhdG9yRXJyb3I5OwogICAgICB9CiAgICB9CiAgfQoKICByZXR1cm4gZ3JvdXBzOwp9CgpmdW5jdGlvbiBnZXROb2RlKHZpc3VhbCwgZGF5U3RhcnQpIHsKICB2YXIgX2dldE5vcm1hbGl6ZWRSYW5nZTMgPSBnZXROb3JtYWxpemVkUmFuZ2UodmlzdWFsLmV2ZW50LCBkYXlTdGFydCksCiAgICAgIF9nZXROb3JtYWxpemVkUmFuZ2U0ID0gX3NsaWNlZFRvQXJyYXkoX2dldE5vcm1hbGl6ZWRSYW5nZTMsIDIpLAogICAgICBzdGFydCA9IF9nZXROb3JtYWxpemVkUmFuZ2U0WzBdLAogICAgICBlbmQgPSBfZ2V0Tm9ybWFsaXplZFJhbmdlNFsxXTsKCiAgcmV0dXJuIHsKICAgIHBhcmVudDogbnVsbCwKICAgIHNpYmxpbmc6IHRydWUsCiAgICBpbmRleDogMCwKICAgIHZpc3VhbDogdmlzdWFsLAogICAgc3RhcnQ6IHN0YXJ0LAogICAgZW5kOiBlbmQsCiAgICBjaGlsZHJlbjogW10KICB9Owp9CgpmdW5jdGlvbiBnZXRNYXhDaGlsZEluZGV4KG5vZGUpIHsKICB2YXIgbWF4ID0gbm9kZS5pbmRleDsKICB2YXIgX2l0ZXJhdG9yTm9ybWFsQ29tcGxldGlvbjExID0gdHJ1ZTsKICB2YXIgX2RpZEl0ZXJhdG9yRXJyb3IxMSA9IGZhbHNlOwogIHZhciBfaXRlcmF0b3JFcnJvcjExID0gdW5kZWZpbmVkOwoKICB0cnkgewogICAgZm9yICh2YXIgX2l0ZXJhdG9yMTEgPSBub2RlLmNoaWxkcmVuW1N5bWJvbC5pdGVyYXRvcl0oKSwgX3N0ZXAxMTsgIShfaXRlcmF0b3JOb3JtYWxDb21wbGV0aW9uMTEgPSAoX3N0ZXAxMSA9IF9pdGVyYXRvcjExLm5leHQoKSkuZG9uZSk7IF9pdGVyYXRvck5vcm1hbENvbXBsZXRpb24xMSA9IHRydWUpIHsKICAgICAgdmFyIGNoaWxkID0gX3N0ZXAxMS52YWx1ZTsKICAgICAgdmFyIGNoaWxkTWF4ID0gZ2V0TWF4Q2hpbGRJbmRleChjaGlsZCk7CgogICAgICBpZiAoY2hpbGRNYXggPiBtYXgpIHsKICAgICAgICBtYXggPSBjaGlsZE1heDsKICAgICAgfQogICAgfQogIH0gY2F0Y2ggKGVycikgewogICAgX2RpZEl0ZXJhdG9yRXJyb3IxMSA9IHRydWU7CiAgICBfaXRlcmF0b3JFcnJvcjExID0gZXJyOwogIH0gZmluYWxseSB7CiAgICB0cnkgewogICAgICBpZiAoIV9pdGVyYXRvck5vcm1hbENvbXBsZXRpb24xMSAmJiBfaXRlcmF0b3IxMS5yZXR1cm4gIT0gbnVsbCkgewogICAgICAgIF9pdGVyYXRvcjExLnJldHVybigpOwogICAgICB9CiAgICB9IGZpbmFsbHkgewogICAgICBpZiAoX2RpZEl0ZXJhdG9yRXJyb3IxMSkgewogICAgICAgIHRocm93IF9pdGVyYXRvckVycm9yMTE7CiAgICAgIH0KICAgIH0KICB9CgogIHJldHVybiBtYXg7Cn0KCmZ1bmN0aW9uIGFkZFRpbWUoaWRlbnRpZmllciwgbWludXRlcykgewogIHZhciByZW1vdmVNaW51dGVzID0gaWRlbnRpZmllciAlIDEwMDsKICB2YXIgdG90YWxNaW51dGVzID0gcmVtb3ZlTWludXRlcyArIG1pbnV0ZXM7CiAgdmFyIGFkZEhvdXJzID0gTWF0aC5mbG9vcih0b3RhbE1pbnV0ZXMgLyA2MCk7CiAgdmFyIGFkZE1pbnV0ZXMgPSB0b3RhbE1pbnV0ZXMgJSA2MDsKICByZXR1cm4gaWRlbnRpZmllciAtIHJlbW92ZU1pbnV0ZXMgKyBhZGRIb3VycyAqIDEwMCArIGFkZE1pbnV0ZXM7Cn0="},{"version":3,"sources":["../../../../src/components/VCalendar/modes/stack.ts"],"names":[],"mappings":"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","sourcesContent":["import { CalendarEventOverlapMode, CalendarEventVisual } from 'types'\nimport { getOverlapGroupHandler, getVisuals, hasOverlap, getNormalizedRange } from './common'\nimport { getTimestampIdentifier } from '../util/timestamp'\n\ninterface Group {\n  start: number\n  end: number\n  visuals: CalendarEventVisual[]\n}\n\ninterface Node {\n  parent: Node | null\n  sibling: boolean\n  index: number\n  visual: CalendarEventVisual\n  start: number\n  end: number\n  children: Node[]\n}\n\nconst FULL_WIDTH = 100\n\nconst DEFAULT_OFFSET = 5\n\nconst WIDTH_MULTIPLIER = 1.7\n\n/**\n * Variation of column mode where events can be stacked. The priority of this\n * mode is to stack events together taking up the least amount of space while\n * trying to ensure the content of the event is always visible as well as its\n * start and end. A sibling column has intersecting event content and must be\n * placed beside each other. Non-sibling columns are offset by 5% from the\n * previous column. The width is scaled by 1.7 so the events overlap and\n * whitespace is reduced. If there is a hole in columns the event width is\n * scaled up so it intersects with the next column. The columns have equal\n * width in the space they are given. If the event doesn't have any to the\n * right of it that intersect with it's content it's right side is extended\n * to the right side.\n */\n\nexport const stack: CalendarEventOverlapMode = (events, firstWeekday, overlapThreshold) => {\n  const handler = getOverlapGroupHandler(firstWeekday)\n\n  // eslint-disable-next-line max-statements\n  return (day, dayEvents, timed) => {\n    if (!timed) {\n      return handler.getVisuals(day, dayEvents, timed)\n    }\n\n    const dayStart = getTimestampIdentifier(day)\n    const visuals = getVisuals(dayEvents, dayStart)\n    const groups = getGroups(visuals, dayStart)\n\n    for (const group of groups) {\n      const nodes: Node[] = []\n\n      for (const visual of group.visuals) {\n        const child = getNode(visual, dayStart)\n        const index = getNextIndex(child, nodes)\n\n        if (index === false) {\n          const parent = getParent(child, nodes)\n          if (parent) {\n            child.parent = parent\n            child.sibling = hasOverlap(child.start, child.end, parent.start, addTime(parent.start, overlapThreshold))\n            child.index = parent.index + 1\n            parent.children.push(child)\n          }\n        } else {\n          const [parent] = getOverlappingRange(child, nodes, index - 1, index - 1)\n          const children = getOverlappingRange(child, nodes, index + 1, index + nodes.length, true)\n\n          child.children = children\n          child.index = index\n\n          if (parent) {\n            child.parent = parent\n            child.sibling = hasOverlap(child.start, child.end, parent.start, addTime(parent.start, overlapThreshold))\n            parent.children.push(child)\n          }\n\n          for (const grand of children) {\n            if (grand.parent === parent) {\n              grand.parent = child\n            }\n\n            const grandNext = grand.index - child.index <= 1\n            if (grandNext && child.sibling &&\n              hasOverlap(child.start, addTime(child.start, overlapThreshold), grand.start, grand.end)) {\n              grand.sibling = true\n            }\n          }\n        }\n\n        nodes.push(child)\n      }\n\n      calculateBounds(nodes, overlapThreshold)\n    }\n\n    visuals.sort((a, b) => (a.left - b.left) || (a.event.startTimestampIdentifier - b.event.startTimestampIdentifier))\n\n    return visuals\n  }\n}\n\nfunction calculateBounds (nodes: Node[], overlapThreshold: number) {\n  for (const node of nodes) {\n    const { visual, parent } = node\n    const columns = getMaxChildIndex(node) + 1\n    const spaceLeft = parent ? parent.visual.left : 0\n    const spaceWidth = FULL_WIDTH - spaceLeft\n    const offset = Math.min(DEFAULT_OFFSET, FULL_WIDTH / columns)\n    const columnWidthMultiplier = getColumnWidthMultiplier(node, nodes)\n    const columnOffset = spaceWidth / (columns - node.index + 1)\n    const columnWidth = spaceWidth / (columns - node.index + (node.sibling ? 1 : 0)) * columnWidthMultiplier\n\n    if (parent) {\n      visual.left = node.sibling\n        ? spaceLeft + columnOffset\n        : spaceLeft + offset\n    }\n\n    visual.width = hasFullWidth(node, nodes, overlapThreshold)\n      ? FULL_WIDTH - visual.left\n      : Math.min(FULL_WIDTH - visual.left, columnWidth * WIDTH_MULTIPLIER)\n  }\n}\n\nfunction getColumnWidthMultiplier (node: Node, nodes: Node[]): number {\n  if (!node.children.length) {\n    return 1\n  }\n\n  const maxColumn = node.index + nodes.length\n  const minColumn = node.children.reduce((min, c) => Math.min(min, c.index), maxColumn)\n\n  return minColumn - node.index\n}\n\nfunction getOverlappingIndices (node: Node, nodes: Node[]): number[] {\n  const indices: number[] = []\n  for (const other of nodes) {\n    if (hasOverlap(node.start, node.end, other.start, other.end)) {\n      indices.push(other.index)\n    }\n  }\n  return indices\n}\n\nfunction getNextIndex (node: Node, nodes: Node[]): number | false {\n  const indices = getOverlappingIndices(node, nodes)\n  indices.sort()\n\n  for (let i = 0; i < indices.length; i++) {\n    if (i < indices[i]) {\n      return i\n    }\n  }\n  return false\n}\n\nfunction getOverlappingRange (node: Node, nodes: Node[], indexMin: number, indexMax: number, returnFirstColumn = false): Node[] {\n  const overlapping: Node[] = []\n  for (const other of nodes) {\n    if (other.index >= indexMin && other.index <= indexMax && hasOverlap(node.start, node.end, other.start, other.end)) {\n      overlapping.push(other)\n    }\n  }\n  if (returnFirstColumn && overlapping.length > 0) {\n    const first = overlapping.reduce((min, n) => Math.min(min, n.index), overlapping[0].index)\n    return overlapping.filter(n => n.index === first)\n  }\n  return overlapping\n}\n\nfunction getParent (node: Node, nodes: Node[]): Node | null {\n  let parent: Node | null = null\n  for (const other of nodes) {\n    if (hasOverlap(node.start, node.end, other.start, other.end) && (parent === null || other.index > parent.index)) {\n      parent = other\n    }\n  }\n  return parent\n}\n\nfunction hasFullWidth (node: Node, nodes: Node[], overlapThreshold: number): boolean {\n  for (const other of nodes) {\n    if (other !== node &&\n      other.index > node.index &&\n      hasOverlap(node.start, addTime(node.start, overlapThreshold), other.start, other.end)) {\n      return false\n    }\n  }\n\n  return true\n}\n\nfunction getGroups (visuals: CalendarEventVisual[], dayStart: number): Group[] {\n  const groups: Group[] = []\n\n  for (const visual of visuals) {\n    const [start, end] = getNormalizedRange(visual.event, dayStart)\n    let added = false\n\n    for (const group of groups) {\n      if (hasOverlap(start, end, group.start, group.end)) {\n        group.visuals.push(visual)\n        group.end = Math.max(group.end, end)\n        added = true\n        break\n      }\n    }\n\n    if (!added) {\n      groups.push({ start, end, visuals: [visual] })\n    }\n  }\n\n  return groups\n}\n\nfunction getNode (visual: CalendarEventVisual, dayStart: number): Node {\n  const [start, end] = getNormalizedRange(visual.event, dayStart)\n\n  return {\n    parent: null,\n    sibling: true,\n    index: 0,\n    visual,\n    start,\n    end,\n    children: [],\n  }\n}\n\nfunction getMaxChildIndex (node: Node): number {\n  let max = node.index\n  for (const child of node.children) {\n    const childMax = getMaxChildIndex(child)\n    if (childMax > max) {\n      max = childMax\n    }\n  }\n  return max\n}\n\nfunction addTime (identifier: number, minutes: number): number {\n  const removeMinutes = identifier % 100\n  const totalMinutes = removeMinutes + minutes\n  const addHours = Math.floor(totalMinutes / 60)\n  const addMinutes = totalMinutes % 60\n\n  return identifier - removeMinutes + addHours * 100 + addMinutes\n}\n"],"sourceRoot":""}]}